**MED_CI

Этот раздел для описания и концентрации знаний по всем технологиям, используемым на проекте.
Если вы столкнулись с проблемой и нашли решение, поделитесь кратко технологией и хорошими ресурсами.


ВАЖНО!
Если вы модифицировали логику или привнесли функционал,
или нашли дополнительные полезные ресурсы, то
обязательно допишите здесь полезную информацию для всех.

*******Утилитарные классы*******

**DateConvertor**
Бин с набором методов для конвертации даты или времени в строку и обратно
На проекте мы будем принимать и отдавать время в одном формате который прописан в конверторе

**Generator**
Бин в котором находятся методы для генерации различных последовательностей

**GlobalRestExceptionHandler**
Любой класс с аннотацией @RestControllerAdvice является глобальным обработчиком исключений, который гибко настраивается.
Метод имеющий аннотацию @ExceptionHandler, в котором, можно определить обрабатываемые исключения.
https://habr.com/ru/post/528116/
https://www.baeldung.com/exception-handling-for-rest-with-spring#controlleradvice

**Open Feign Client**
Служит для общения с различными сторонними сервисами. В данном проекте общается с интеграционной тестовой системой.
https://medium.com/@kirill.sereda/spring-cloud-netflix-feign-по-русски-7b8272e8e110

*******Различные библиотеки*******

**Lombok** - Существенно сокращает код благодаря собственным аннотациям.
Позволяет не писать геттеры, сеттеры, конструкторы, Equals, toString и т.д.
В аннотированном классе все необходимые методы будут сгенерированы во время компиляции.
https://projectlombok.org/features/

- @Getter/@Setter сгенерирует геттеры и сеттеры для всех полей класса.
- @NoArgsConstructor - создаст конструктор без параметров.
- @RequiredArgsConstructor – создаст конструктор только для final полей.
- @AllArgsConstructor – создаст конструктор для всех полей.
- @builder создаст билдер вместо конструктора (согласно шаблону builder)

- **_**

**_Code Style_**
- Убрать импорт \*, должны импортироваться только нужные пакеты Settings -> Editor -> Code Style -> Java -> Imports ->
Class count to use import with '\*' = 999, Names count to use static import with '\*' = 999.

- Отступы должны быть 4 пробела, не использовать табуляцию Settings -> Editor -> Code Style -> Java -> Tabs and Indents
-> Use tab character должен быть отключен, Tab size = 4, Ident = 4, Label indent = 0.

- Все ветки ДОЛЖНЫ ответвляться от ветки master предварительно обновив ее, чтоб было меньше конфилктов.

- НЕЛЬЗЯ делать коммиты и пушить напрямую в ветку master или любую другую не вашу ветку.
 
**_**

**_ТЕСТИРОВАНИЕ_**

**Unit testing**
https://habr.com/ru/post/169381/

**Integration testing**
https://www.youtube.com/watch?v=Lnc3o8cCwZY

**Code Coverage**
Это инструмент, позволяющий выяснить, какой процент кода покрыт тестами.
Чтобы запустить программу в этом режиме нужно нажать на значок щита рядом с кнопкой Run.
Coverage высчитывается для текущей выбранной конфигурации запуска.
https://www.youtube.com/watch?v=QDFI19lj4OM

**MockMvc**
позволяет проводить интеграционное тестирование API имитируя запросы к приложению.
Избавляет от написания отдельного RestTemplate-приложения
https://www.baeldung.com/integration-testing-in-spring

**Mockito**
https://habr.com/ru/post/444982/
https://www.youtube.com/watch?v=Wmrdfzzpr6A
https://www.youtube.com/watch?v=lpPEAHLGoJg

**_**

**РАБОТА С СУЩНОСТЯМИ**

**DTO** (_Data Transfer Object_)
https://habr.com/ru/post/513072/
шаблон проектирования, используемый для передачи данных между подсистемами приложения.
DTO объект является упрощенным представлением Entity. DTO - это не сущность это POJO!
В нашем приложении эндпоинты принимаю с фронта и отдают на фронт DTO.

DTO имеет ряд преимуществ перед Entity:

1) Инкапсулирует поля Entity, которые мы бы не хотели показывать при передаче DTO куда-либо.
2) Entity внутри себя может хранить ссылки на объекты. Если будем передавать ее на фронт, то эти объекты будут
   подтягиваться из бд.
   Если такие объекты еще и ссылаются друг на друга, мы можем получить StackOverFlow.
3) DTO не должен содержать какую-либо бизнес-логику
4) Можно сгруппировать несколько сущностей в одну DTO, если фронт это устраивает.
5) Если мы принимаем и отдаем ДТО, мы можем спокойно рефакторить сущности и бизнес логику не боясь уронить фронт

**Связи между сущностями**

- _@OneToOne_
  https://www.baeldung.com/jpa-one-to-one
  Эта связь используется, когда например у каждого гражданина может быть один паспорт, а у паспорта один гражданин.
  Эту связь можно сделать однонаправленной и двунапрвленной.
  Однонаправленная связь:
  В однонаправленной связи только одна сущность имеет поле или свойство связи, которое ссылается на другую.
  Связанное поле объявлено с помощью аннотации @JoinColumn, параметр name которой обозначает
  поле в БД для создания связи.
  В однонаправленных отношениях одна из сторон (и только одна) должна быть владельцем и
  нести ответственность за обновление связанных полей. Т.е если удаляется user из базы, то сначала JPA самостоятельно
  определяет наличие паспорта, удаляется сначала его и только потом самого юзера.
  Двунаправленная связь:
  В двунаправленной связи каждый объект имеет поле или свойство отношения, которое ссылается на другой объект.
  Обратная сторона двунаправленного отношения должна ссылаться на свою сторону-владельца с помощью элемента mappedBy.
  Элемент mappedBy обозначает свойство или поле в сущности, которая является владельцем отношения.
  Использование общего первичного ключа с @MapsId
  Это означает что источник и цель имеют одни и те же значения первичного ключа.
  В таблице это выглядит так, убирается колонка с pk и остается колонка с fk другой таблицы.

- _@OneToMany_
  https://www.baeldung.com/hibernate-one-to-many
  В этом отношении каждая строка одного обьекта ссылается на множество записей в другом обьекте.
  Но если связь будет однонаправленная, то создаться третья таблица, где будут
  храниться FK двух таблиц, как при связи @ManyToMany.

- _@ManyToOne_
  Это когда на один объект (столбец или набор столбцов) ссылается на другой объект, которые содержат уникальные
  значения.
  Сторона-владелец этих отношений обычно находится в @ManyToOne и mappedBy в родительском объекте
  Так же эта связь может быть однонаправленная и двунаправленная.
  В таблице это выглядит так: в таблице, которая считается владельцем, находится FK второй таблицы.

- _@ManyToMany_
  https://www.baeldung.com/jpa-many-to-many
  При этой связи создается третья таблица(Join Table), где мы можем увидеть связь между
  строками двух других таблиц.
  Столбцы Join Table- это FK, которые ссылаютя на PK связываемых таблиц.

**_**

**Стратегии генерации Id**

IDENTITY
Указывает, что для генерации значения первичного ключа будет использоваться столбец IDENTITY,
имеющийся в базе данных. Значения в столбце автоматически увеличиваются, что позволяет базе
данных генерировать новое значение при каждой операции вставки.

SEQUENCE
Указывает, что для получения значений первичного ключа Hibernate должен использовать имеющиеся
в базе данных механизмы генерации последовательных значений (Sequence).
SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе.
Используя аннотацию @SequenceGenerator, мы можем указать конкретное имя последовательности для таблицы, а также
иные параметры.
Для каждой последовательности сгенерированные значения являются уникальными.
Так, мы можем назначать разные последовательности разным сущностям и они будут брать айдишники из этой
последовательности.
В зависимости от требований приложения, можно иметь один генератор на всё приложение, по генератору на каждую
сущность или несколько генераторов, которыми пользуются несколько сущностей.
SEQUENCE - это тип генерации, рекомендуемый документацией Hibernate.

**_**

**_РАБОТА С БД_**

**HQL** - https://java-online.ru/hibernate-hql.xhtml
**SQL Учебник** - https://www.schoolsw3.com/sql/index.php

**JpaRepository** - Для простых CRUD запросов используйте готовые методы JpaRepository.
Для более сложных запросов можно использовать аннотацию @query над методом и
там прописать SQL запрос.
https://sysout.ru/spring-data-jpa-zaprosy-generiruemye-po-imeni-metoda/
https://habr.com/ru/post/435114/

**Flyway**
это инструмент миграции (переноса) базы данных. Проще говоря, это инструмент,
который помогает вам выполнять сценарии базы данных при развертывании приложений.
Flyway поддерживает два типа сценариев, SQL и Java. Вы можете упаковать сценарий в приложение.
Когда приложение запускается, Flyway управляет выполнением этих сценариев.
Эти сценарии называются миграцией Flyway.
Flyway создаст таблицу в вашей БД для записи выполнения миграции.
Имя таблицы по умолчанию:flyway_schema_history. В данном проекте все сценарии хранятся в ресурсах > db.migrations.
Основная информации по ссылкам по порядку вполне достаточно для освоения:
https://www.youtube.com/watch?v=ArM7nCys4hY
https://www.youtube.com/watch?v=61ChGaqxELw


**Нормализация баз данных**

**Нормализация баз данных** — это процесс организации и структурирования базы данных с целью 
сокращения избыточности данных. Проще говоря, процесс нормализации базы данных — это способ убедиться в том, что каждое 
поле и запись организованы логически таким образом, чтобы не только избежать избыточности, но и сделать использование 
любой реляционной базы данных более эффективным: избежать ошибок ввода данных, случайного 
удаления, а также облегчить процесс обновления данных. 

Процесс проектирования БД с использованием метода НФ является итерационным и заключается в последовательном переводе 
отношения из 1НФ в НФ более высокого порядка по определенным правилам. Каждая следующая НФ ограничивается определенным 
типом функциональных зависимостей и устранением соответствующих аномалий при выполнении операций над отношениями БД, 
а также сохранении свойств предшествующих НФ.

Первая нормальная форма диктует, что каждое поле вашей базы данных должно хранить только одно значение и что в одной
базе данных не должно быть двух полей, одинаково хранящих информацию.

Вторая нормальная форма направлена на уменьшение избыточности, гарантируя, что каждое поле хранит информацию, 
которая говорит нам что-то о первичном ключе. 
Другими словами:
-	Каждая база данных должна иметь только один первичный ключ
-	Все непервичные ключи должны полностью зависеть от первичного ключа.     

Эти два принципа гарантируют, что каждая база данных хранит последовательную информацию об одном и том же аргументе, 
который содержится в первичном ключе. 

База данных соответствует третьей нормальной форме, если в ней нет ни одной 
переходной зависимости. Переходная зависимость возникает, когда столбец B в вашей 
базе данных зависит от столбца A, который зависит от первичного ключа. Чтобы нормализовать базу данных в соответствии 
с третьей нормальной формой, необходимо удалить столбец B, который не зависит напрямую от первичного ключа, 
и хранить эту информацию во второй базе данных с собственным первичным ключом.

Хорошая презентация с примерами:
https://docs.google.com/presentation/d/1oMTCr79UvEJ526EXXDe5PFumVqIWXZNTlNNX_nqhxF8/edit#slide=id.g7e000a0d1e_0_0

**Ограничения столбцов и таблиц** 

При определении таблиц и их столбцов в SQL мы можем использовать ряд атрибутов, 
которые накладывают определенные ограничения. 
- С помощью выражения PRIMARY KEY столбец можно сделать первичным ключом. 
- Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут UNIQUE.
- Чтобы указать, может ли столбец принимать значение NULL, при определении столбца ему можно задать атрибут 
NULL или NOT NULL. Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать 
значение NULL. Исключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае 
по умолчанию столбец имеет значение NOT NULL.
- Атрибут DEFAULT определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет 
предусмотрено значение, то для него будет использоваться значение по умолчанию.
- Ключевое слово CHECK задает ограничение для диапазона значений, которые могут храниться в столбце. 
Для этого после слова CHECK указывается в скобках условие, которому должен соответствовать столбец 
или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100.
- С помощью ключевого слова CONSTRAINT можно задать имя для ограничений. В качестве ограничений 
могут использоваться PRIMARY KEY, UNIQUE, CHECK. Имена ограничений можно задать на уровне столбцов. 
Они указываются после CONSTRAINT перед атрибутами.
В принципе необязательно задавать имена ограничений, при установке соответствующих атрибутов SQL Server 
автоматически определяет их имена. Но, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.
Подробнее тут:
https://metanit.com/sql/postgresql/2.4.php

**_Направление в отношениях сущностей_**

Направление отношений может быть как двунаправленным, так и однонаправленным. Двунаправленные отношения имеют 
как сторону-владельца, так и владеемую сторону. Однонаправленные отношения имеют только сторону-владельца.
Сторона-владелец отношения определяет, как среда выполнения Persistence обновляет отношение в базе данных.  

**В двунаправленном отношении** каждая сущность имеет поле, которое ссылается на другую сущность. Через 
это поле код первой сущности может получить доступ ко второй сущности, находящейся на другой стороне отношений. 
Если у первой сущности есть поле, ссылающееся на вторую сущность, и наоборот, то в этом случае говорят, что
обе сущности знают друг о друге, и что они состоят в двунаправленных отношениях.
Двунаправленные отношения должны следовать следующим правилам:
 1. Элемент mappedBy определяет поле в объекте, который является владельцем отношения. 
    Если применить атрибут mappedBy на одной стороне связи, 
    то Hibernate не станет создавать сводную таблицу.
 2.	Сторона many в отношениях many-to-one всегда является владельцем отношений и не может определять 
    элемент mappedBy (такого параметра у аннотации @ManyToOne просто нет).
 3.	Для двунаправленных отношений one-to-one, сторона-владелец - это та сторона, 
    чья таблица имеет столбец с внешним ключом на другую таблицу. Если не указан параметр mappedBy, 
    то колонки с айдишниками появляются у каждой таблицы.
 4.	Для двунаправленных отношений many-to-many, любая сторона может быть стороной-владельцем. 

**В однонаправленных отношениях** только одна сущность имеет поле, которое ссылается на вторую сущность. 
Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях.
Владелец связи и владеемый
По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице 
одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся 
владельцем связи, вторая сущность - владеемой.
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем 
этой связи по умолчанию,
Основное отличие заключается в том, что двунаправленная связь обеспечивает навигационный доступ в 
обоих направлениях, так что вы можете получить доступ к другой стороне без явных запросов. 
Также это позволяет вам применять каскадные параметры в обоих направлениях.
  Подробнее: 
  https://habr.com/ru/post/542328/

**Типы загрузки коллекций в базу:**

- fetch = FetchType.LAZY - не загружает отношения, если вы не вызываете его с помощью метода getter.
- fetch = FetchType.EAGER - загружаются все отношения.
  Плюсы и минусы:
- Lazy initialization повышает производительность, избегая ненужных вычислений и уменьшая требования к памяти.
- Eager initialization потребляет больше памяти, а скорость обработки медленная.
  https://java-online.ru/hibernate-entities.xhtml
  https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-jpa/jpa-otnosheniia-sushchnostei

**_**

**_РАБОТА С КОНТРОЛЛЕРАМИ_**
**Swagger** - Это фреймворк для спецификации RESTful API. С его помощью можно удобно отправлять запросы на сервер.
Web интерфейс Swagger доступен после старта проекта и аутентификации под определенным юзером
по адресу: http://localhost:8080/swagger-ui/index.html#/ (значение порта 8080 может быть настроено в
application.properties: server.port=)
Информация по SWAGGER - https://habr.com/ru/post/434798/
Настройка в классе SwaggerConfig.
Кратко по работе со Swagger:
После запуска проекта перейдя по адресу: http://localhost:8080/swagger-ui/index.html загрузится
веб интерфейс Swagger. Нам будет доступен контроллер для аутентификации auth-controller
с помощью которого мы можем отправить запрос типа LoginRequest, содержащий два строковых поля:
email и password на сервер (нажать try it out -> вместо string подставить значения -> execute).
При успешной аутентификации получаем ответ типа JwtResponse содержащий сгенерированный токен
(начинается на Bearer), id, email, roles. Для его добавления в header при каждом последующем
запросе нужно скопировать его значение без кавычек, нажать Authorize (кнопка с замочком) ->
вставить значение в поле value -> Authorize (замочек поменяет значение на закрытый).
Для тестирования работы методов контроллера выбираем нужный -> try it out -> вводим необходимые
данные -> execute.

**_**

**_РАБОТА С ВЕТКАМИ_**

**Сохранение изменений при переключении между ветками**
Бывает, при работе на одной ветке нужно на время переключиться на другую. Если просто перейти на другую ветку
изменения, оставленные на первой, не сохранятся.
Сохраниться можно двумя способами:

- закоммитить изменения,
- выложить изменения "на полку".
  В первом случае все останется в коммите, что неплохо, но тогда при дальнейшей работе измененные и
  созданные файлы не будут отображаться характерным образом в дереве проекта. Это может понизить удобство работы.
  Во втором же случае все изменения до последнего коммита будут извлечены из дерева в Shelf и останутся там во время
  переходов между ветками, затем могут быть выгружены обратно в проект при необходимости, а после, если больше
  не будут нужны, могут быть удалены для порядка во вкладке Shelf.
  Чтобы выложить изменения на полку, в разделе Commit нужно выбрать нужные файлы, затем нажать Shelve Silently,
  после чего они появятся в соседней вкладке Shelf.
  Чтобы вернуть их обратно, во вкладке Shelf выбираем файлы и жмем Unshelve Silently, после чего изменения
  снова в дереве.

**_**

**_Почтовый сервис_**

**Отправка электронных писем с помощью Spring**
Ссылки:
https://habr.com/ru/company/otus/blog/557798/
https://www.baeldung.com/java-email
Отправка писем по почте в проекте реализована следующим образом:
1) Нужна зависимость spring-boot-starter-mail в pom.xml.
2) В пропертях прописываются конфигурации нашей почты как отправителя для Spring, относящиеся к SMTP-серверу
почтового сервиса, которым мы пользуемся.
3) Создан класс MailService (src/main/java/academy/kata/mismono1/util/MailService.java), в котором реализован 
метод для отправки простого письма, принимающий 3 параметра: email, тема письма и сам текст. Этот класс является
утилитным, и занимается только непосредственной отправкой писем. 
  Формы самих писем, в зависимости от назначения, создаются в классе MessageService, расположенном в той же директории,
путем создания формирующих методов.
  Единственный нюанс заключается в том, что у проекта нет аккаунта в почте, который можно было бы использовать
без связи с личными данными, поэтому по умолчанию просто отправить письмо не получится. Но если в пропертях 
ввести логин, пароль (точнее, настроенный в аккаунте почты пароль внешних приложений) и настройки SMTP-сервера, 
то все работает.
Подробнее про отправку почты. Тест пройдет с данными, которые сейчас есть в программе. Но чтобы разобраться и потренироваться
надо отправить реальное письмо. Для этого в файле application.yaml идем в настройки почты
   mail:
   host: smtp.mail.ru
   port: 465
   username: myEmail
   password: xn2Ls55wiYMEpggV0Hk9
Здесь надо временно(!!!) только на время своего теста заменить myEmail на свой реальный мейл и пароль на свой реальный 
внешний пароль. Чтобы создать внешний пароль набираем в поиске что-то вроде "как создать внешний пароль к почте" и следуем
подсказкам. Здесь настройки для почты mail. Если вы захотите использовать gmail то, как минимум, надо будет еще менять порт.
После этого в классе MailService опять же временно (!!!) меняете строку smm.setFrom("noReply: " + username); на аналогичную 
без "noReply: ".  Теперь можно отправить реальное письмо с одной своей почты на другую ))).
Не забудьте потом вернуть настройки!  Если вы оставите свой мейл и пароль в проперти, и сделаете коммит, то они окажутся
в открытом доступе. Пароль можно будет у себя потом удалить, но лучше так не делать. А если вы не вернете строку с
"noReply: "- в программе упадет ряд тестов.

**_**

**_Аннотация @Transactional простыми словами_**

1. Spring создает proxy для классов или методов, объявленных аннотацией @Transactional. Proxy в большинстве случаев невидим
во время выполнения. Он предоставляет способ для Spring вводить поведение “до”, “после” или “во время” вызовов методов в
proxy-объект. Поэтому, когда мы определяем метод с @Transactional, Spring динамически создает proxy. Когда клиенты 
совершают вызовы в наш объект, вызовы перехватываются, а поведение будет вводиться через механизм proxy.
Подробнее о Proxy: https://medium.com/@kirill.sereda/транзакции-в-spring-framework-a7ec509df6d2

2. Аннотация @Transactional находится в пакете org.springframework.transaction.annotation и не стоит путать ее с 
"javax.transaction.Transactional." Собственная аннотация Spring предоставляет более расширенные возможности настройки, 
которые рассматриваются дальше. Аннотацию "javax.transaction.Transactional" Spring также поддерживает, но лучше 
использовать родные аннотации.
Подробнее про работу Transactional под капотом: https://habr.com/ru/post/532000/

3. Основные правила транзакций:
3.1. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих
других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта (ACID – Atomicity,
Consistency, Isolation, Durability (Атомарность, Согласованность, Изолированность, Долговечность))
3.2. Не вызывайте метод, помеченный @Transactional из одного кл
3.3. @Transactional не откатит транзакцию из-за Exception, используйте RuntimeException
3.4. Помечайте @Transactional только public методы
3.5. Помните, что @Transactional занимает соединение с БД, выносите долгую логику за пределы транзакции
Ссылка на хорошее видео: https://www.youtube.com/watch?v=2E8FKi4oC0o

4. Популярные ошибки при работе с транзакциями
4.1. Вызовы в пределах одного класса.
4.2. Обработка не всех исключений.
4.3. Уровни изоляции транзакций и распространение.
4.4. Транзакции не блокируют данные.
4.5. Два разных источника данных.
Подробнее об этих проблемах и пути решений: https://habr.com/ru/company/otus/blog/574470/

**_**

**_ОТЛАДКА КОДА_**

Если вы обнаружили, что ваш код работает не так, как вы ожидали, например, вылетает с исключением или возвращает
неправильное значение, пришло время воспользоваться дебаггером.
Вы можете столкнуться с разными ошибками. Некоторые из них легко обнаруживаются,
например, синтаксические - о них сразу сообщит компилятор. Но есть ошибки, поиск и исправление
которых могут отнять очень много времени.  Например, малозаметная логическая ошибка в начале программы,
которая может проявиться очень поздно и стать серьезной проблемой.
Отладчик позволяет приостановить выполнение программы и изучить построчное изменение переменных, чтобы понять,
в каком состоянии находится программа в определенном месте.

**Пример использования на проекте**
Если возникают проблемы после запуска теста, точка останова на контроллере поможет понять, происходит ли
авторизация и передаются ли данные в сервисы, а точки останова в ваших методах в соответствующих имплементациях
сервисов – какие данные передаются на каждом этапе выполнения программы, и что возвращается обратно в контроллер.

**Базовый пошаговый сценарий отладки**

1. Установка breakpoints (точки останова).
   Точки останова бывают четырех видов:
   на строку / на переменную / на метод / на класс (последние две замедляют отладку).
   Чтобы проверить, как программа работает во время выполнения, вам нужно приостановить ее выполнение
   перед подозрительным фрагментом кода.
   Можно сделать это двумя способами:
   Нажмите ЛКМ на левую боковую панель в нужной вам строке
   Кликните курсором по месту кода и нажмите Ctrl + F8

2. Запуск в режиме Debug
   Для запуска теста в режиме Debug необходимо выбрать Debug вместо Run. Тест начнется как обычно, но, когда он
   достигнет точки останова, в секции Debug появится окно отладчика со списком переменных и их значений, что
   может помочь в определении возможных проблем в тестовых данных или возвращаемых значениях.

3. Управление отладкой
   Над окном отладчика расположена панель элементов управления отладкой, в которой в основном используются
   два элемента:
   Step Over / F8 (идти по коду без захода в методы, чтобы выполнить следующую строку кода)
   Step Into / F7 (идти по коду с заходом в каждый метод на пути выполнения кода)

**Evaluate Expression**
Одна из дополнительных функций, которую можно использовать во время отладки, это Evaluate Expression.
Эта функция позволяет вычислить значение любого выражения, которое находится в текущей области видимости отладчика,
и получить результат вычисления в режиме реального времени. Это очень удобно, когда нужно проверить какое-либо
значение или выражение в процессе выполнения программы.

**Mute Breakpoints**
Если вы установили несколько точек останова и нужно сделать их неактивными (замьютить), можно использовать кнопку
Mute Breakpoints в секции Debug слева в вертикальной панели.

**View Breakpoints**
Чтобы посмотреть, какие точки останова вы уже установили, можно зайти в Debug в левом нижнем углу и
найти кнопку View Breakpoints или нажать Ctrl+Shift+F8.

**Java Exceptions Breakpoints**
Одна из полезных функций Java Exception Breakpoints в IntelliJ IDEA - добавление неявного брейкпоинта, который
позволяет программе остановиться перед выбрасыванием любого исключения или конкретного типа.
Для этого нужно выбрать Java Exceptions Breakpoints в верхнем левом углу лекции Debug и указать имя
исключения из предложенного списка.

Документация по отладке в IntellijIDEA:
https://www.jetbrains.com/help/idea/debugging-your-first-java-application.html

Базовые уроки по отладке:
https://javarush.com/groups/posts/2463-debug-v-intellij-idea-gayd-dlja-novichkov
https://youtu.be/RqyKWN98fos

Основы отладки и расширенная лекция от JetBrains:
https://youtu.be/59RC8gVPlvk
https://youtu.be/40Og3hTV--k

**_**

**_ДОПОЛНИТЕЛЬНЫЙ ЗАПРОС В ONE TO ONE_**
https://vladmihalcea.com/hibernate-lazytoone-annotation/

**_ Интеграционная тестовая система _**

В пропертях проекта есть креды от тестовой системы. Registrar переходит по ссылке 
"api/doctor/check/patient" и передает данные пациента (снилс, паспорт, полис), где под капотом, через 
Feign Client, вначале проверяется токен, если токен протух или null, то отправляются креды на тестовую систему, получает
Java Web Token и Expiration Date (дату окончания действия токена, 1 час). После чего перезаписываются в 
responseJwtTokenTestSystem. Оттуда достаем JWT, кладем его в header (в тестовой системе авторизация реализована через
web token, поэтому, чтобы перейти на нужный нам эндпоинт, нам надо отправить header). Далее request, который мы передали,
идет на эндпоинт для роли Checker (регистрар авторизовался под этой ролью), там проверяется header, если он действующий, 
имеет нужную роль, тогда проверяется в базе данных тестовой системы. Если документы пациента будут найдены, 
мы получим response с тестовой системы и статус пациента FOUND, если такого пациента в тестовой системы не будет, мы 
получим STATUS.NOT_FOUND

**_**

**_ TELEGRAM BOT _**

Для создания телеграм бота необходимо через строку поиска в телеграме найти @BotFather
Пишем ему /start и получаем список всех его команд.
Отправляем ему команду /newbot . Бот просит придумать имя нашему новому боту. Единственное ограничение на имя — оно должно 
оканчиваться на «bot». В случае успеха BotFather возвращает токен бота
Имя бота, заканчивающееся на bot и token пишем в файле application.yaml
Для проверки функциональности бота 
необходимо настроить почтовый сервис (выше сказано как это сделать)
также желательно добавить записи в таблицы role и users
Примеры скриптов, где  yourEmail@yandex.ru - Ваш реальный email:

INSERT INTO role (id, name)
VALUES
(100, 'PATIENT')

INSERT INTO users (id, dtype, email, password, snils, first_name, last_name, patronymic, birthday, gender, is_enabled, role_id)
VALUES
(10, 'Patient', 'yourEmail@yandex.ru', '$2a$12$Qsizn.Wo0VjZM6kpaPyuYeULF0ppd1mND3389lQPChAbFMrGhpUdG', '000-000-000 00', 'Ivan', 'Ivanov', 'Ivanovich', '1990-06-25', 'MALE', false, 100)

INSERT INTO patient_history (id, patient_id)
VALUES
(200, 10);

Для проверки scheduled task необходимо заполнить таблицы:
INSERT INTO role (id, name)
VALUES (300, 'DOCTOR')

INSERT INTO users (id, dtype, email, password, snils, first_name, last_name, patronymic, birthday, gender, is_enabled,
role_id)
VALUES
(52, 'Doctor', 'doctor52@email.com', '$2a$12$Qsizn.Wo0VjZM6kpaPyuYeULF0ppd1mND3389lQPChAbFMrGhpUdG',
'000-000-000 52', 'Irina1', 'Petrova1', 'Olegovna', '1980-08-08', 'FEMALE', true, 300),
(53, 'Doctor', 'doctor53@email.com', '$2a$12$Qsizn.Wo0VjZM6kpaPyuYeULF0ppd1mND3389lQPChAbFMrGhpUdG',
'000-000-000 53', 'Irina2', 'Petrova2', 'Olegovna', '1980-08-08', 'FEMALE', true, 300)

INSERT INTO medical_organization(id, code, name, legal_address, ogrn, start_date, end_date,
full_employment_status_range, director_id, io_director_id)
VALUES (1, '700', 'med', 'address', '000', '2010-09-09', '2025-09-09', 223.75, null, null)


INSERT INTO department (id, name, age_type, chief_doctor_id, io_chief_doctor_id, medical_organization_id)
VALUES (1, 'Surgery', 'ADULT', null, 53, 1),
(2, 'Therapy', 'CHILD', null, null, 1),
(3, 'Economic', 'NO', null, null, 1)

INSERT INTO employee_history(dtype, id, is_public, department_id, employee_id)
VALUES ('DoctorHistory', 3, true, 1, 52),
('DoctorHistory', 5, true, 2, 53)

INSERT INTO talon(id, time, doctor_history_id, patient_history_id)
VALUES
(9000, (CURRENT_DATE + INTERVAL '1 DAY'):: timestamp + INTERVAL '10 HOURS', 5, 200)


Видео по созданию телеграм ботов на youtube:

https://youtu.be/t9OTDHuF7_M

https://youtu.be/X49LG8JhcGQ

https://youtu.be/jeMOyjRGY8s**

**_**

**_ Запланированные задачи (@Scheduled) _** 

Аннотировать метод с помощью @Scheduled заставляя его запускаться в определенное время или 
через определенный промежуток времени.
Статей полно. Для примера можно почитать: 
https://coderlessons.com/articles/java/rabotat-vovremia-s-zaplanirovannymi-zadachami-spring

Для логирования использовал связку Slf4j и Logback
Хорошая статья: 
https://urvanov.ru/2019/07/08/%D0%BB%D0%BE%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81-slf4j-%D0%B8-logback/

**_**